# 정렬

##  메모리는 어떻게 동작 할까?
컴퓨터는 아주 많은 서랍을 갖고 있고 각각의 서랍에는 주소가 붙어 있다.  
내가 컴퓨터에 뭔가를 저장하려고 서랍 하나를 요청하면 컴퓨터는 서랍의 주소를 알려 준다.  
이 메모리라는 서랍에 물건 하나가 아니라 여러 개의 물건을 한꺼번에 한 공간에 저장 하고 싶을 때 배열과 리스트를 사용할 수 있다.

## 배열
배열은 일단 필요한 크기를 지정해서 메모리 공간을 확보하면 내가 지정한 크기만큼만 물건을 보관할 수 있어.  
내가 여러개의 물건을 보관하겠다고 만든 배열 크기가 5인데 그보다 큰 6개의 물건을 나란히 저장할 수 없는 거야.  
이럴 경우에 나는 6개의 물건을 저장하기 위해 또 다른 메모리 공간에 배열을 새로 만들어야돼.  
그럼 여유롭게 배열 크기를 15로 지정 하면 되지 않을까? 그러면 메모리가 쓸데없이 낭비된다.

##  연결 리스트
연결리스트를 사용하면 메모리의 빈 공간에 자유롭게 새로운 물건을 추가할 수 있어.  
연결리스트는 요소들이 서로 연결되어 있다.  
첫번째 요소로 가면 두번째 요소로 갈 수 있는 주소값을 알려주고  
두번째는 세번째를 알려주는 식으로 이렇게 서로 연결되어 있어.  
 그래서 요소 하나를 얻어내려면 그 요소로 향할 때까지 처음부터 순차적으로 접근할 수밖에 없어.


## 수행 속도
배열은 인덱스가 있어서 임의접근 가능해. 배열의 어느 요소든지 인덱스로 바로 찾아낼 수 있어서 수행시간이 O(1)이야.  
리스트는 서로 연결되어 있어. 순차접근만 가능해서 수행시간이 O(n)이야. 모든 요소를 다 읽어봐야하거든.  
배열은 읽기속도가 빨라. 인덱스 덕분에 O(1)이다.  
연결 리스트는 이전 원소가 뭘 가르키는지만 바꿔주면 되니까 삽입할때도 O(1) 삭제도 O(1)이야. 빠름.


## 선택정렬

내 음악 어플에 있는 여섯 개의 노래 중에서 내가 제일 많이 재생한 노래를 순서대로 정렬하고 싶어.  
일단 무작위로 나열 되어 있는 노래 목록 중에서 재생횟수 제일 큰 걸 찾아서 새 목록 첫 번째에 적어야겠지.  
그러고 남은 5개 노래들 중에서 제일 재생 수 많은 걸 뽑아서 새 목록 두 번째에 갖다놓고.   
이렇게 순서대로 정렬 된 세 리스트를 얻으려면 6개의 노래를 6번 살펴 봐야겠지.  
O(n)실행시간이 걸리는 연산을 n번 해야돼. 결국 정렬 알고리즘은 O(n^2)시간이 걸린다.  
