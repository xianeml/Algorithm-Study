# 분할 정복
분할 정복은 문제를 푸는 전략이다.  
1. 가장 간단한 경우로 기본 단계를 찾는다.  
2. 주어진 문제를 작게 줄여서 기본 단계가 되도록 만드는 방법을 찾는다.  
   
   
## 직사각형 농장을 최대 크기의 정사각형이 되도록 나누기

일단 내가 직사각형의 농장을 갖고 있는데 이거를 똑같이 생긴 정사각형 토지들로 똑같이 나누고싶어    
정사각형의 토지 크기는 최대한 크게 하면서 절대 직사각형으로 나누면 안 돼.  
분할 정복 전략은 재귀적 알고리즘이야. 문제해결에 두 단계를 거쳐.  
1. 첫 번째 단계는 기본 단계야. 이 부분은 가능한한 간단한 문제여야 돼.  
2. 그 다음은 문제가 기본 단계가 될 때까지 나누거나 작게 만들면 돼.  문제를 최대한 작게 보는 거지.  
일단 이 가로 1680m 세로 640m 의 토지를 기본 단계로 풀어 보자.  
가장 쉬운 기본 단계는 농장의 한 변의 길이가 다른 변의 배수가 되는 경우를 들 수 있어.  
예를들면 세로 길이가 25m 고 가로 길이가 50 m 인 경우야.  
 그럼 가로를 절반으로 짜르면 가로세로 25m 의 정사각형 두개로 나눌 수 있지.  
이제 재귀 단계를 풀어야 돼.  
어떻게 하냐면 함수를 호출 할 때마다 문제를 작게 나눠야 돼  
가로 세로 640 m 짜리 정사각형 두 개를 만들면 400m 의 가로길이를 가진 직사각형 토지가 하나 남지.  
이제 그것도 정사각형으로 쪼개고 남은 걸 또 쪼개면 이렇게 정사각형 모양으로 전체 농장을 나눌 수 있어.  
이걸 어떻게 증명할 수 있을까 증명은 쉽지 않은데 일단 이게 사실이라는 걸 믿고 진행을 해야 돼(유클리드 알고리즘).  
마지막 남은 80m 에서 정사각형을 발견하게 돼 이제 기본 단계 도달 한거야.  
그래 80 m 짜리 토지크기로 원래 농장을 정사각형으로 일정하게 나눌 수 있어.


## 숫자 배열의 합계 구하기
### 반복문 사용:  

```
def sum(arr):
    total = 0
    for x in arr:
        total += x
    return total

print(sum([1,2,3,4]))
```

### 재귀함수 사용:  
1. 기본단계 : 가장 간단한 배열 찾기 - 
`원소의 갯수가 0이거나 1개인 배열`
2. 재귀단계 : 재귀함수 호출할 때마다 배열의 크기 기본단계로 쪼개기  

```
def sum(list):
    if list == []:
        return 0
    return list[0] + sum(list[1:])
```

# 퀵 정렬
분할 정복 전략을 사용하는 퀵 정렬 알고리즘은 선택 정렬보다 훨씬 빠르다.  
### 배열정렬하기
1.기본단계 찾기   
배열 크기가 0이거나 1이면 합계 구할 필요 없으니까 그대로 리턴

```
def quicksort(array):
    if len(array) < 2:
        return array
```

2.재귀단계  

배열에서 기준 원소를 찾는다.  
기준 원소 보다 작은 원소와 큰 원소로 분류 한다.

이제 기준 원소 앞뒤로 하위 배열들이 생기면 얘네들도 재귀함수 호출해서 정렬 한다.   

```
def quicksort(array):
    if len(array) < 2:
        return array
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot]
        greater = [i for i in array[1:] if i > pivot]
        return quicksort(less) + [pivot] + quicksort(greater)

print(quicksort([10, 5, 2, 3]))
```

### 귀납적 증명
기본단계가 동작하니 그 다음 재귀단계도 동작하겠구나

### 리스트에서 최댓값 구하기  
```
def max(list):
    if len(list) == 2:
        return list[0] if list[0] > list[1] else list[1]
    sub_max = max(list[1:])
    return list[0] if list[0] > sub_max else sub_max
```

